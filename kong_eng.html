<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4YZHC1G9FN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-4YZHC1G9FN');
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Mate Kong- Two Player small Grid Word Game | Soosooland</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="format-detection" content="telephone=no" />

    <!-- SEO Meta Tags -->
    <meta name="description" content="Two-player word battle in small grid. Brain Rot Prevention Games ">
    <meta name="keywords" content="K-game,K-game for Brain Training, Korean Educational Games,Korean word game, word search, word puzzle">
    <meta name="author" content="Soosooland">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Mate Kong- Two Player Word Game">
    <meta property="og:description" content="Two-player word battle in small grid">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://soosooland.com/kong/kong_eng.html">
    <meta property="og:image" content="https://soosooland.com/images/worpuzz.jpeg">
    <meta property="og:site_name" content="Soosooland">
    <link rel="canonical" href="https://soosooland.com/kong/kong_eng.html">
    <link rel="alternate" hreflang="ko" href="https://soosooland.com/kong/kong_kor.html">
    <link rel="alternate" hreflang="en" href="https://soosooland.com/kong/kong_eng.html">
    <link rel="stylesheet" href="https://soosooland.com/css/protection.css">
    <script src="https://soosooland.com/js/protection.js"></script>
 <style>
          * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }


  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow-x: hidden;
    position: fixed;
    width: 100%;
    -webkit-overflow-scrolling: touch;
  }
  
  body {
    font-family: 'Noto Sans KR', sans-serif;
    background-color: #f0f8f7;
    color: #333;
    text-align: center;
    padding: 10px;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
     
.back-button {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 8px 10px;      /* Î™®Î∞îÏùº Í∏∞Î≥∏ */
    font-size: 1.5em;
    font-weight: bold;
    background-color: #CFF9FF;
    color: #0A6A79;
    border-radius: 12px;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 100;
}
.back-button:hover {
    background-color: #1baf8f;
    color: #fff;
}
   h1 {
    font-size: clamp(18px, 4vw, 24px);
    font-weight: bold;
    color: #064d4d;
    margin: 5px;
  }
  
  p {
    font-size: clamp(14px, 3vw, 18px);
    color: #064d4d;
    margin: 5px;
}
    .game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex: 1;
    max-width: 100vw;
    overflow: hidden;
  }
  
  .player-input input {
    font-size: clamp(16px, 3vw, 18px);
    padding: 6px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: clamp(120px, 30vw, 150px);
    text-align: center;
  }
  
  .start-section {
    margin-bottom: 10px;
  }
  
  .guess-section {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
    flex-wrap: wrap;
    padding: 0 10px;
  }
  
  .guess-section input {
    font-size: clamp(16px, 3vw, 18px);
    padding: 6px;
    border: 1px solid #aaa;
    border-radius: 4px;
    width: clamp(150px, 40vw, 200px);
    min-width: 150px;
  }
  
  .game-area {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: clamp(8px, 2vw, 15px);
    margin-bottom: 10px;
    width: 100%;
    max-width: 100vw;
    overflow: hidden;
  }
  
  .game-button {
    font-size: clamp(14px, 3vw, 16px);
    background-color: #c8f4ee;
    padding: clamp(8px, 2vw, 10px) clamp(12px, 3vw, 18px);
    margin: 4px;
    color: #064d4d;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    touch-action: manipulation;
    white-space: nowrap;
  }
  
  .game-button:hover, .game-button:active {
    background-color: #1d9e95;
    transform: scale(1.02);
  }
  
  .cell {
    width: 100%;
    height: 100%;
    background-color: #ddd;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.5em;
    cursor: pointer;
    border: 1px solid #999;
    touch-action: manipulation;
  }
  
  .revealed { 
    background-color: #fff; 
   font-size: 1.5em;
 
  }
  
  .word-owned-player1 { 
    background-color: #b7d5f2; 
  }
  
  .word-owned-player2 { 
    background-color: #f6c28b; 
  }
  
  #player1Score, #player2Score {
    width: 180px;
    height: 328px;
    padding: 8px;
    font-size: 1.2em;
    font-weight: bold;
    border: 2px solid #333;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }
  
  #player1Score { 
    background-color: #b7d5f2; 
  }
  
  #player2Score { 
    background-color: #f6c28b; 
  }
  
  #currentTurn {
    font-size: clamp(14px, 3vw, 18px);
    margin: 8px;
    color: #056762;
    font-weight: bold;
  }
  
  #game {
    display: grid;
    grid-template-columns: repeat(8,1fr);
    grid-template-rows:repeat(8,1fr);
    grid-gap: 4px;
    padding: 8px;
    border: 2px solid #333;
    background-color: #eee;
    width: 328px;
    height:328px;
  }
  
  .hidden {
    display: none;
  }
  
  .controls {
    margin-top: 10px;
    display: flex;
    justify-content: center;
    gap: 8px;
    flex-wrap: wrap;
  }
  
  #wrongGuesses {
    font-size: clamp(12px, 2.5vw, 14px);
    margin: 5px 0;
    padding: 0 10px;
    word-wrap: break-word;
  }
.inline { display: inline; }
  
  /* ÏïÑÏù¥Ìå®Îìú ÏÑ∏Î°ú Î™®Îìú ÏµúÏ†ÅÌôî */
  @media screen and (max-width: 690px) and (orientation: portrait) {
    body {
      padding: 5px;
    }
    
    .game-area {
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    #player1Score, #player2Score {
      width: 328px;
      height: auto;
      display: flex;
      flex-direction: column;
      order: 3;
    }
    
    #game {
      order: 1;
      margin-bottom: 10px;
    }
    
    #currentTurn {
      order: 2;
    } 
  }
  
  
</style>
</head>

<body>
 <button class="back-button"  onclick="location.href='index.html'">‚Üê</button>

<h1 id="game-title">Í≤åÏûÑ Ï†úÎ™©</h1>
<p id="game-desc">Í≤åÏûÑ ÏÑ§Î™Ö</p>

<div class="game-container" id="game-container">

  <div id="gameSection" class="hidden">
    <div id="currentTurn"></div>


<div class="guess-section">
  <input type="text" id="guessInput" placeholder="YOUR GUESS(UPPERCASE)" />
  <button id="guessBtn" class="game-button">SUBMIT</button>
  <button id="retryBtn" class="game-button">‚Üª Restart</button>
</div>

<div id="wrongGuesses" style="display: none;">
  <strong>Invalid words:</strong> <span id="wrongList"></span>
</div>

<div class="game-area">
  <div id="player1Score"></div>
  <div id="game"></div>
  <div id="player2Score"></div>
</div>

  </div>

</div>
<script>
let words = []; // Ï†ÑÏó≠ Î≥ÄÏàò ÏÑ†Ïñ∏

window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const poolFile = urlParams.get('pool');
  if (!poolFile) {
    // ÏûÑÏãúÎ°ú Í∏∞Î≥∏ Îã®Ïñ¥Îì§ ÏÑ§Ï†ï
    words = ['CAT', 'AREA','ALSO','ABOUT','AGAIN','ACTION','ACTRESS'];
    gameSection.classList.remove('hidden');
    startGame();
    return;
  }

  fetch('wordpools/' + poolFile + '.json')
    .then(res => res.json())
    .then(data => {
      document.getElementById('game-title').textContent = data.title || 'Í≤åÏûÑ Ï†úÎ™©';
      const rawText = data.description || 'Í≤åÏûÑ ÏÑ§Î™Ö';
      const htmlText = rawText.replace(/\n/g, '<br>');
      document.getElementById('game-desc').innerHTML = htmlText; // innerHTMLÎ°ú Î≥ÄÍ≤Ω

      words = [];
      for (let length in data.words) {
        const count = data.wordCount[length] || 0;
        words.push(...getRandomSample(data.words[length], count));
      }
          
  startGame(); // Ïó¨Í∏∞Ïóê!
})
.catch(err => {
  document.body.innerHTML = '<p>‚ùå ÏõåÎìúÌíÄ Î°úÎî© Ï§ë Ïò§Î•ò Î∞úÏÉù: ' + err.message + '</p>';
});


  const gridSize = 8;
  const totalCells = gridSize * gridSize;
  let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;

let clovers = new Set(), daisies = new Set(), resultShown = false, gameStarted = false;
let player1 = "ÌîåÎ†àÏù¥Ïñ¥1", player2 = "ÌîåÎ†àÏù¥Ïñ¥2", currentPlayerName = "", wrongGuesses = [];
let words = []; // Ïù¥ Ï§Ñ Ï∂îÍ∞Ä!

  const gameEl = document.getElementById('game');
  const player1ScoreEl = document.getElementById('player1Score');
  const player2ScoreEl = document.getElementById('player2Score');
  const retryBtn = document.getElementById('retryBtn');
  const startBtn = document.getElementById('startBtn');
  const gameSection = document.getElementById('gameSection');
  const currentTurnEl = document.getElementById('currentTurn');
  const guessInput = document.getElementById('guessInput');
  const guessBtn = document.getElementById('guessBtn');
  const wrongListEl = document.getElementById('wrongList');
  const wrongGuessesEl = document.getElementById('wrongGuesses');

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function getRandomSample(arr, count) {
    if (count >= arr.length) return [...arr];
    const shuffled = [...arr];
    shuffle(shuffled);
    return shuffled.slice(0, count);
  }

   function startGame() {
     player1 = "player1";
     player2 = "player2";
    gameSection.classList.remove('hidden');
    gameStarted = true;
    
    init();
  }

  function init() {
    board = Array(totalCells).fill(null);
    revealed = Array(totalCells).fill(false);
    wordMap = {};
    foundWords = new Set();
    foundBy = { player1: [], player2: [] };
    currentPlayer = 'player1';
    usedIndexes = new Set();
    clovers.clear();
    daisies.clear();
    wrongGuesses = [];
    wrongListEl.textContent = "";
    wrongGuessesEl.style.display = 'none';
    resultShown = false;

    gameEl.innerHTML = '';
    for (let i = 0; i < totalCells; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.onclick = () => { if (!resultShown) handleClick(i); };
      gameEl.appendChild(cell);
    }

    // Î∞©Ìñ• Í≤ÄÏ¶ùÍ≥º Ìï®Íªò Îã®Ïñ¥ Î∞∞Ïπò
    if (placeAllWordsWithVariety()) {
    } else {
      let placedWords = [];
      shuffle(words);
      
      for (let word of words) {
        let placed = false;
        for (let attempt = 0; attempt < 500; attempt++) {
          if (placeWord(word)) {
            placedWords.push(word);
            placed = true;
            break;
          }
        }
        if (!placed) {
          
        }
      }
    }
    
    // ÌÅ¥Î°úÎ≤Ñ/Îç∞Ïù¥ÏßÄ Î∞∞Ïπò (Îã®Ïñ¥ ÏòÅÏó≠ ÌîºÌïòÍ∏∞)
    placeDaisies(7);
    placeClovers(7);
    fillEmptyCells();
    updateScore();
    updateTurnDisplay();
    
    // Í≤åÏûÑ Ï¢ÖÎ£å Ï°∞Í±¥ ÌôïÏù∏
    checkGameEnd();
  }

  function canPlaceWord(word, x, y, dx, dy) {
    for (let i = 0; i < word.length; i++) {
      let nx = x + dx * i, ny = y + dy * i;
      if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) return false;
      
      let idx = ny * gridSize + nx;
      if (board[idx] && board[idx] !== word[i]) return false;
      if (usedIndexes.has(idx)) return false;
    }
    return true;
  }

  function placeWord(word) {
    const directions = [
      { x: 1, y: 0 },   // Í∞ÄÎ°ú (Ïò§Î•∏Ï™Ω)
      { x: 0, y: 1 },   // ÏÑ∏Î°ú (ÏïÑÎûò)
      { x: 1, y: 1 },   // ÎåÄÍ∞ÅÏÑ† (Ïò§Î•∏Ï™Ω ÏïÑÎûò)
    ];
    
    // Î∞©Ìñ•ÏùÑ Î¨¥ÏûëÏúÑÎ°ú ÏÑûÏñ¥ÏÑú Îçî Îã§ÏñëÌïú Î∞∞Ïπò
    const shuffledDirections = directions.sort(() => Math.random() - 0.5);
   
    for (let dir of shuffledDirections) {
const startY = Math.floor(Math.random() * gridSize);
for (let i = 0; i < gridSize; i++) {
  const y = (startY + i) % gridSize;
  for (let x = 0; x < gridSize; x++) {

          

if (canPlaceWord(word, x, y, dir.x, dir.y)) {
            let positions = [];
            for (let i = 0; i < word.length; i++) {
              let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridSize + nx;
              board[idx] = word[i];
              usedIndexes.add(idx);
              positions.push(idx);
            }
            wordMap[word] = {
              positions: positions,
              direction: [dir.x, dir.y] // Î∞©Ìñ• Ï†ïÎ≥¥ Ï†ÄÏû•
            };
            return true;
          }
        }
      }
    }
    return false;
  }

  function checkDirectionVariety() {
    let directionCount = {
      '1,0': 0,    // Í∞ÄÎ°ú
      '0,1': 0,    // ÏÑ∏Î°ú
      '1,1': 0     // ÎåÄÍ∞ÅÏÑ†
    };
    
    // wordMapÏóêÏÑú Í∞Å Îã®Ïñ¥Ïùò Î∞©Ìñ• Ï≤¥ÌÅ¨
    for (let word in wordMap) {
      const direction = wordMap[word].direction;
      const key = direction[0] + ',' + direction[1];
      if (directionCount.hasOwnProperty(key)) {
        directionCount[key]++;
      }
    }
    
    // 3Î∞©Ìñ• Î™®Îëê ÏÇ¨Ïö©ÎêêÎäîÏßÄ ÌôïÏù∏
    return directionCount['1,0'] > 0 && directionCount['0,1'] > 0 && directionCount['1,1'] > 0;
  }

  function placeAllWordsWithVariety() {
    let attempts = 0;
    const maxAttempts = 10;
    
    do {
      // Ï¥àÍ∏∞Ìôî
      board = Array(totalCells).fill(null);
      usedIndexes.clear();
      wordMap = {};
      
      // Î™®Îì† Îã®Ïñ¥ Î∞∞Ïπò ÏãúÎèÑ
      let allPlaced = true;
      const shuffledWords = [...words].sort(() => Math.random() - 0.5);
      
      for (let word of shuffledWords) {
        if (!placeWord(word)) {
          allPlaced = false;
          break;
        }
      }
      
      if (allPlaced && checkDirectionVariety()) {
        return true; // ÏÑ±Í≥µ
      }
      
      attempts++;
      
    } while (attempts < maxAttempts);
    
    return false; // Ïã§Ìå®
  }

  function placeClovers(count) {
    let placed = 0;
    let attempts = 0;
    while (placed < count && attempts < 1000) {
      const idx = Math.floor(Math.random() * totalCells);
      if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
        // Ï£ºÎ≥ÄÏóê Îã®Ïñ¥Í∞Ä ÏóÜÎäîÏßÄ ÌôïÏù∏
        

if (isSafeForSpecial(idx)) {
          clovers.add(idx);
          placed++;
        }
      }
      attempts++;
    }
    
  }

  function placeDaisies(count) {
    let placed = 0;
    let attempts = 0;
    while (placed < count && attempts < 1000) {
      const idx = Math.floor(Math.random() * totalCells);
      if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
        // Ï£ºÎ≥ÄÏóê Îã®Ïñ¥Í∞Ä ÏóÜÎäîÏßÄ ÌôïÏù∏
        if (isSafeForSpecial(idx)) {
          daisies.add(idx);
          placed++;
        }
      }
      attempts++;
    }
    
  }
function isSafeForSpecial(idx) {
  const x = idx % gridSize;
  const y = Math.floor(idx / gridSize);
  
  // Ï£ºÎ≥Ä 8Ïπ∏Ïóê Îã§Î•∏ ÏïÑÏù¥ÌÖúÏù¥ ÏûàÎäîÏßÄÎßå ÌôïÏù∏ (Îã®Ïñ¥Îäî ÏÉÅÍ¥ÄÏóÜÏùå)
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
        const nIdx = ny * gridSize + nx;
        if (clovers.has(nIdx) || daisies.has(nIdx)) {
          return false;
        }
      }
    }
  }
  return true;
}


  function fillEmptyCells() {
    const filler = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    shuffle(filler);
    let i = 0;
    for (let j = 0; j < totalCells; j++) {
      if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
        board[j] = filler[i++ % filler.length];
      }
    }
  }

  function reveal(index) {
    if (revealed[index]) return;
    revealed[index] = true;
    const cell = gameEl.children[index];
    
    if (clovers.has(index)) {
      cell.textContent = 'üçÄ';
      // ÏÉÅÌïòÏ¢åÏö∞ 4Ïπ∏ Ïó¥Í∏∞
      const directions = [-gridSize, gridSize, -1, 1];
      for (let d of directions) {
        const newIdx = index + d;
        if (newIdx >= 0 && newIdx < totalCells) {
          // Ï¢åÏö∞ Ïù¥Îèô Ïãú Í∞ôÏùÄ ÌñâÏóê ÏûàÎäîÏßÄ ÌôïÏù∏
          if (d === -1 || d === 1) {
            if (Math.floor(index / gridSize) === Math.floor(newIdx / gridSize)) {
              reveal(newIdx);
            }
          } else {
            reveal(newIdx);
          }
        }
      }
      } else if (daisies.has(index)) {
  const img = document.createElement('img');
  img.src = 'daisy_64x64.png';
  img.alt = 'Daisy';
  img.style.width = '24px';
  img.style.height = '24px';
  cell.appendChild(img);
      // Ï£ºÎ≥Ä 8Ïπ∏ Î™®Îëê Ïó¥Í∏∞
      const x = index % gridSize;
      const y = Math.floor(index / gridSize);
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            const nIdx = ny * gridSize + nx;
            if (!revealed[nIdx]) reveal(nIdx);
          }
        }
      }
    } else {
      cell.textContent = board[index];
    }
    cell.classList.add('revealed');
  }

  function updateScore() {
    player1ScoreEl.innerHTML = `<strong>${player1}</strong><br><br>` + foundBy.player1.map(w => ` ${w}`).join("<br>");
    player2ScoreEl.innerHTML = `<strong>${player2}</strong><br><br>` + foundBy.player2.map(w => ` ${w}`).join("<br>");
  }

  function updateTurnDisplay() {
    if (!gameStarted) return;
    currentPlayerName = currentPlayer === 'player1' ? player1 : player2;
    currentTurnEl.textContent = `It is ${currentPlayerName}'s turn.`;
  }

  function switchTurn(extra) {
    if (!extra) {
      currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
    }
    updateTurnDisplay();
  }

  function handleClick(index) {
    if (revealed[index] || resultShown || !gameStarted) return;
    
    const extra = clovers.has(index) || daisies.has(index);
    reveal(index);
    checkWords();
    checkGameEnd();
    
    if (!resultShown) {
      switchTurn(extra);
    }
  }

  function checkWords() {
    for (let word of Object.keys(wordMap)) {
      if (foundWords.has(word)) continue;
      const pos = wordMap[word].positions; // .positions Ï∂îÍ∞Ä
      if (pos.every(i => revealed[i])) {
        foundWords.add(word);
        foundBy[currentPlayer].push(word);
        pos.forEach(i => {
          const cell = gameEl.children[i];
          cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
        });
        updateScore();
      }
    }
  }

  function checkGameEnd() {
    const totalWords = Object.keys(wordMap).length;
    if (foundWords.size >= totalWords && totalWords > 0) {
      resultShown = true;
      
      setTimeout(() => {
        alert("game over!");
      }, 500);
    }
  } 

  function handleGuess() {
    if (!gameStarted) return;
    
    const guess = guessInput.value.trim();
    guessInput.value = "";
    if (!guess || foundWords.has(guess)) return;
    
    if (wordMap[guess]) {
      const pos = wordMap[guess].positions; // .positions Ï∂îÍ∞Ä
      pos.forEach(i => {
        if (!revealed[i]) reveal(i);
      });
      foundWords.add(guess);
      foundBy[currentPlayer].push(guess);
      pos.forEach(i => {
        const cell = gameEl.children[i];
        cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
      });
      updateScore();
      checkGameEnd();
    } else {
      if (!wrongGuesses.includes(guess)) {
        wrongGuesses.push(guess);
        wrongListEl.textContent = wrongGuesses.join(", ");
        wrongGuessesEl.style.display = 'block';
      }
    }
    
    if (!resultShown) {
      switchTurn(false);
    }
  }

  function retry() {
    if (!gameStarted) return;
    init();
  }

  retryBtn.onclick = retry;
  guessBtn.onclick = handleGuess;
  guessInput.addEventListener('keypress', e => {
    if (e.key === 'Enter') handleGuess();
  });
};
</script>
</body>
</html>
